<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MORTAL ARENA: REBORN</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Bangers&display=swap');
        
        :root {
            --p1-color: #ffae00;
            --p2-color: #00ccff;
            --ui-bg: #111;
            --ui-border: #444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Bangers', cursive;
            overflow: hidden;
            color: white;
        }

        /* Scanline Effect */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #gameContainer {
            position: relative;
            width: 1000px;
            height: 600px;
            background: #000;
            border: 4px solid #333;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        /* UI Layer */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .health-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .player-wrapper {
            position: relative;
            width: 45%;
            display: flex;
            flex-direction: column;
        }

        .player-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            margin-bottom: 5px;
            text-transform: uppercase;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            justify-content: space-between;
        }

        .p1-name { color: var(--p1-color); }
        .p2-name { color: var(--p2-color); text-align: right; flex-direction: row-reverse;}

        .bar-frame {
            background: #222;
            height: 30px;
            border: 3px solid #fff;
            position: relative;
            transform: skewX(-15deg);
            box-shadow: 0 4px 0 #000;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
            position: relative;
        }

        .p1-health .bar-fill {
            background: linear-gradient(90deg, #ff8800, #ffcc00);
            float: right;
        }

        .p2-health .bar-fill {
            background: linear-gradient(90deg, #0088ff, #00ffff);
            float: left;
        }

        /* Damage overlay (white flash) */
        .damage-flash {
            position: absolute;
            top: 0;
            bottom: 0;
            background: #fff;
            width: 0%;
            transition: width 0.1s ease-out;
            pointer-events: none;
            mix-blend-mode: overlay;
        }
        .p1-health .damage-flash { right: 0; }
        .p2-health .damage-flash { left: 0; }

        .timer-box {
            width: 80px;
            height: 60px;
            background: #000;
            border: 3px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 32px;
            color: #fff;
            position: absolute;
            left: 50%;
            transform: translateX(-50%) skewX(-15deg);
            box-shadow: 4px 4px 0 #333;
            z-index: 5;
        }
        
        .timer-val {
            transform: skewX(15deg); /* Counter skew text */
        }

        /* Center Text (Fight, Wins) */
        #centerText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 80px;
            color: #fff;
            text-shadow: 5px 5px 0 #d32f2f, 0 0 20px rgba(255, 255, 255, 0.8);
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s;
            line-height: 1.5;
        }

        .show-text {
            opacity: 1 !important;
            transform: translate(-50%, -50%) scale(1) !important;
        }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 40px;
            color: #d32f2f;
            text-shadow: 4px 4px 0 #fff, 0 0 20px #f00;
            margin-bottom: 40px;
            letter-spacing: 5px;
        }

        .btn {
            background: #333;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 30px;
            border: 2px solid #fff;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn:hover {
            background: #fff;
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 15px #fff;
        }

        .controls-info {
            margin-top: 30px;
            font-family: monospace;
            color: #aaa;
            text-align: center;
            line-height: 1.6;
            font-size: 14px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 4px;
        }
        
        .key {
            display: inline-block;
            background: #444;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
            margin: 0 2px;
            font-weight: bold;
            border-bottom: 2px solid #222;
        }

        /* Toggle Switch for AI */
        .toggle-container {
            display: flex;
            align-items: center;
            margin: 20px 0;
            font-family: 'Bangers', cursive;
            font-size: 24px;
            letter-spacing: 2px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-left: 15px;
        }
        
        .switch input { opacity: 0; width: 0; height: 0; }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border: 2px solid #fff;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
        }
        
        input:checked + .slider { background-color: var(--p2-color); }
        input:checked + .slider:before { transform: translateX(26px); }

        /* Combo Counter */
        #comboContainer {
            position: absolute;
            top: 150px;
            font-size: 40px;
            font-weight: bold;
            pointer-events: none;
            display: none;
            z-index: 15;
        }
        
        .combo-count {
            color: #ffcc00;
            text-shadow: 3px 3px 0 #d32f2f;
            font-size: 60px;
        }
        
        .combo-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #fff;
            letter-spacing: 2px;
        }

        #fpsCounter {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            z-index: 20;
        }

    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div id="ui">
            <div class="health-container">
                <div class="player-wrapper p1-health">
                    <div class="player-name p1-name"><span>SCORPION</span></div>
                    <div class="bar-frame">
                        <div class="bar-fill" id="health1"></div>
                        <div class="damage-flash" id="flash1"></div>
                    </div>
                </div>

                <div class="timer-box">
                    <span class="timer-val" id="timer">60</span>
                </div>

                <div class="player-wrapper p2-health">
                    <div class="player-name p2-name"><span>SUB-ZERO</span></div>
                    <div class="bar-frame">
                        <div class="bar-fill" id="health2"></div>
                        <div class="damage-flash" id="flash2"></div>
                    </div>
                </div>
            </div>

            <div id="comboContainer" style="left: 100px;">
                <div class="combo-count" id="comboNum">2</div>
                <div class="combo-label">HIT COMBO</div>
            </div>
            
            <div id="centerText">ROUND 1<br>FIGHT!</div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="menu-overlay">
            <h1>MORTAL ARENA<br><span style="font-size:20px; color:white;">REBORN</span></h1>
            
            <div class="toggle-container">
                <span>VS CPU</span>
                <label class="switch">
                    <input type="checkbox" id="cpuToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <button class="btn" onclick="startGame()">START FIGHT</button>
            
            <div class="controls-info">
                <strong style="color:var(--p1-color)">PLAYER 1:</strong><br>
                <span class="key">A</span><span class="key">D</span> Move | <span class="key">W</span> Jump | <span class="key">S</span> Crouch<br>
                <span class="key">J</span> Punch | <span class="key">K</span> Kick | <span class="key">L</span> Special<br><br>
                <strong style="color:var(--p2-color)">PLAYER 2:</strong><br>
                <span class="key">←</span><span class="key">→</span> Move | <span class="key">↑</span> Jump | <span class="key">↓</span> Crouch<br>
                <span class="key">1</span> Punch | <span class="key">2</span> Kick | <span class="key">3</span> Special
            </div>
        </div>

        <!-- Game Over Menu -->
        <div id="gameOverMenu" class="menu-overlay hidden">
            <h1 id="winnerText">SCORPION WINS</h1>
            <button class="btn" onclick="resetGame()">REMATCH</button>
            <button class="btn" onclick="location.reload()">MAIN MENU</button>
        </div>

        <div id="fpsCounter">FPS: 60</div>
    </div>

<script>
/**
 * MORTAL ARENA: REBORN
 * An upgraded 2D fighting game engine.
 */

// --- CONSTANTS & CONFIG ---
const CANVAS_W = 1000;
const CANVAS_H = 600;
const GROUND_Y = 480;
const GRAVITY = 0.6;

// Game States
const STATE = {
    MENU: 0,
    READY: 1,
    PLAYING: 2,
    ENDED: 3
};

// Animation States
const ANIM = {
    IDLE: 0,
    WALK: 1,
    JUMP: 2,
    CROUCH: 3,
    PUNCH: 4,
    KICK: 5,
    SPECIAL: 6,
    HIT: 7,
    BLOCK: 8
};

// --- SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    health1: document.getElementById('health1'),
    health2: document.getElementById('health2'),
    flash1: document.getElementById('flash1'),
    flash2: document.getElementById('flash2'),
    timer: document.getElementById('timer'),
    centerText: document.getElementById('centerText'),
    comboContainer: document.getElementById('comboContainer'),
    comboNum: document.getElementById('comboNum'),
    startMenu: document.getElementById('startMenu'),
    gameOverMenu: document.getElementById('gameOverMenu'),
    winnerText: document.getElementById('winnerText'),
    fps: document.getElementById('fpsCounter'),
    cpuToggle: document.getElementById('cpuToggle')
};

// Input Handling
const keys = {};
const justPressed = {}; // For single-frame inputs

document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    justPressed[e.key.toLowerCase()] = true;
    
    // Prevent scrolling with arrows/space
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
});

document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    justPressed[e.key.toLowerCase()] = false;
});

// --- GAME ENGINE ---
let gameState = STATE.MENU;
let gameTime = 0;
let lastTime = performance.now();
let frames = 0;
let fps = 60;
let timer = 60;
let timerInterval = null;

// Screen Shake
let shakeIntensity = 0;
function addShake(amount) { shakeIntensity = amount; }

// Hit Stop (Freeze frame on impact)
let hitStopFrames = 0;
function triggerHitStop(frames = 8) { hitStopFrames = frames; }

// Camera/Background
let bgOffset = 0;

// --- CLASSES ---

class Particle {
    constructor(x, y, color, speed, life, type = 'spark') {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const spd = speed * (0.5 + Math.random());
        this.vx = Math.cos(angle) * spd;
        this.vy = Math.sin(angle) * spd;
        this.life = life;
        this.maxLife = life;
        this.type = type;
        this.size = Math.random() * 4 + 2;
        this.gravity = type === 'blood' ? 0.2 : 0.4;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.vx *= 0.95;
        this.life--;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        
        if (this.type === 'spark') {
            ctx.fillRect(this.x, this.y, this.size, this.size);
        } else if (this.type === 'blood') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

let particles = [];

class Fighter {
    constructor(x, color, isP1) {
        this.pos = { x: x, y: GROUND_Y };
        this.vel = { x: 0, y: 0 };
        this.color = color;
        this.isP1 = isP1; // Player 1 or Player 2
        this.facing = isP1 ? 1 : -1; // 1 = Right, -1 = Left
        
        // Stats
        this.health = 100;
        this.maxHealth = 100;
        this.width = 60;
        this.height = 110;
        
        // State
        this.animState = ANIM.IDLE;
        this.frame = 0;
        this.stateTimer = 0;
        this.isAttacking = false;
        this.isBlocking = false;
        this.isHit = false;
        this.invincible = 0;
        
        // Attack Hitboxes (Defined relative to center)
        this.hitbox = null; 
        
        // Combo
        this.comboCount = 0;
        this.lastHitTime = 0;
    }

    reset() {
        this.pos = { x: this.isP1 ? 200 : 800, y: GROUND_Y };
        this.vel = { x: 0, y: 0 };
        this.health = this.maxHealth;
        this.animState = ANIM.IDLE;
        this.facing = this.isP1 ? 1 : -1;
        this.isHit = false;
        this.isAttacking = false;
        this.comboCount = 0;
    }

    update(enemy) {
        if (this.health <= 0) return;

        // Handle Hit Stop
        if (hitStopFrames > 0) return;

        // State Management
        this.frame++;
        if (this.stateTimer > 0) this.stateTimer--;
        if (this.invincible > 0) this.invincible--;

        // Recovery from hit stun
        if (this.isHit && this.stateTimer <= 0) {
            this.isHit = false;
            this.animState = ANIM.IDLE;
        }

        // Physics
        if (!this.isHit) {
            this.vel.y += GRAVITY;
            this.pos.x += this.vel.x;
            this.pos.y += this.vel.y;
            
            // Friction
            this.vel.x *= 0.85;

            // Boundaries
            if (this.pos.x < 20) this.pos.x = 20;
            if (this.pos.x > CANVAS_W - 20) this.pos.x = CANVAS_W - 20;
        }

        // Ground collision
        if (this.pos.y >= GROUND_Y) {
            this.pos.y = GROUND_Y;
            this.vel.y = 0;
            if (this.animState === ANIM.JUMP) {
                this.animState = ANIM.IDLE;
            }
        }

        // Facing direction (always face enemy unless attacking through them)
        if (!this.isAttacking && Math.abs(this.pos.x - enemy.pos.x) > 20) {
            this.facing = this.pos.x < enemy.pos.x ? 1 : -1;
        }

        // Inputs (or AI)
        if (!this.isHit && !this.isAttacking && gameState === STATE.PLAYING) {
            if (this.isP1 || !ui.cpuToggle.checked) {
                this.handleInput();
            } else {
                this.aiLogic(enemy);
            }
        }
        
        // Clear hitbox after attack duration
        if (this.isAttacking && this.stateTimer <= 0) {
            this.isAttacking = false;
            this.hitbox = null;
            if (this.pos.y === GROUND_Y) this.animState = ANIM.IDLE;
        }
    }

    handleInput() {
        const left = this.isP1 ? 'a' : 'arrowleft';
        const right = this.isP1 ? 'd' : 'arrowright';
        const up = this.isP1 ? 'w' : 'arrowup';
        const down = this.isP1 ? 's' : 'arrowdown';
        const punch = this.isP1 ? 'j' : '1';
        const kick = this.isP1 ? 'k' : '2';
        const special = this.isP1 ? 'l' : '3';

        // Movement
        if (this.pos.y === GROUND_Y) {
            if (keys[left]) {
                this.vel.x = -5;
                this.facing = -1;
                this.animState = ANIM.WALK;
            } else if (keys[right]) {
                this.vel.x = 5;
                this.facing = 1;
                this.animState = ANIM.WALK;
            } else {
                if (this.animState === ANIM.WALK) this.animState = ANIM.IDLE;
            }

            // Crouch
            if (keys[down]) {
                this.animState = ANIM.CROUCH;
                this.vel.x = 0;
            } else if (this.animState === ANIM.CROUCH && !keys[down]) {
                this.animState = ANIM.IDLE;
            }

            // Jump
            if (justPressed[up]) {
                this.vel.y = -14;
                this.animState = ANIM.JUMP;
                justPressed[up] = false; // Consume input
            }
        } else {
            // Air control
            if (keys[left]) { this.vel.x = -4; }
            if (keys[right]) { this.vel.x = 4; }
        }

        // Attacks
        if (justPressed[punch]) this.doAttack(ANIM.PUNCH, 15, 20, 5, 80, 0, 35, 40, 8, false);
        if (justPressed[kick]) this.doAttack(ANIM.KICK, 20, 25, 8, 90, 10, 50, 50, 12, false);
        if (justPressed[special]) this.doAttack(ANIM.SPECIAL, 30, 40, 15, 100, 0, 60, 60, 20, true);
    }

    aiLogic(enemy) {
        const dist = Math.abs(this.pos.x - enemy.pos.x);
        const reactionSpeed = 0.03; // Chance per frame to make a decision

        if (Math.random() < reactionSpeed) {
            if (dist > 80) {
                // Move closer
                if (this.pos.x < enemy.pos.x) keys['arrowright'] = true;
                else keys['arrowright'] = false;
                
                if (this.pos.x > enemy.pos.x) keys['arrowleft'] = true;
                else keys['arrowleft'] = false;

                // Jump randomly
                if (Math.random() < 0.1) justPressed['arrowup'] = true;

            } else {
                // Close range: Attack or Block
                keys['arrowleft'] = false;
                keys['arrowright'] = false;
                
                if (enemy.isAttacking && Math.random() < 0.5) {
                    keys['arrowdown'] = true; // Block/Crouch
                } else {
                    keys['arrowdown'] = false;
                    const r = Math.random();
                    if (r < 0.4) justPressed['1'] = true; // Punch
                    else if (r < 0.7) justPressed['2'] = true; // Kick
                    else if (r < 0.8) justPressed['3'] = true; // Special
                }
            }
        } else {
            // Reset inputs randomly to prevent sticking
            if(Math.random() < 0.1) {
                keys['arrowleft'] = false;
                keys['arrowright'] = false;
            }
        }
    }

    doAttack(animType, duration, hitFrame, damage, width, yOff, hbW, hbH, knock, isSpecial) {
        if (this.isAttacking || this.isHit) return;
        
        this.animState = animType;
        this.isAttacking = true;
        this.stateTimer = duration;
        this.vel.x = 0; // Stop momentum on attack
        
        // Setup delayed hitbox activation
        setTimeout(() => {
            if (gameState === STATE.PLAYING && this.isAttacking) {
                // Create hitbox relative to player center
                this.hitbox = {
                    x: (this.facing === 1 ? 20 : -20) + this.pos.x - (hbW/2),
                    y: this.pos.y - 110 + yOff,
                    w: hbW,
                    h: hbH,
                    damage: damage,
                    knockback: knock * this.facing,
                    isSpecial: isSpecial
                };
            }
        }, (hitFrame / 60) * 1000); // Simple delay mapping

        // Cleanup input trigger
        const keyMap = {'j': 'j', 'k':'k', 'l':'l', '1':'1', '2':'2', '3':'3'};
        // We don't clear the global 'keys', just 'justPressed' is handled by system, 
        // but we need to prevent button mashing resetting the attack state constantly
        // handled by isAttacking check.
    }

    takeDamage(attack) {
        if (this.invincible > 0) return;

        // Calculate damage
        const dmg = attack.damage;
        this.health -= dmg;
        if (this.health < 0) this.health = 0;

        // Effects
        addShake(5);
        triggerHitStop(8);
        createParticles(this.pos.x, this.pos.y - 80, attack.isSpecial ? this.color : '#fff', 10);
        
        // Knockback
        this.vel.x = attack.knockback;
        this.vel.y = -4;
        
        // State change
        this.animState = ANIM.HIT;
        this.isHit = true;
        this.stateTimer = 20;
        this.invincible = 20; // i-frames
        this.comboCount = 0; // Reset own combo
        
        // Health Bar UI Logic
        updateHealthUI();

        // Check Death
        if (this.health <= 0) {
            this.animState = ANIM.HIT; // Stay on floor roughly
            endRound(this.isP1 ? 'PLAYER 2 WINS' : 'PLAYER 1 WINS');
        }
    }

    draw(ctx) {
        ctx.save();
        
        // Positioning
        const cx = this.pos.x;
        const cy = this.pos.y;
        const dir = this.facing; // 1 or -1

        // Flip if facing left
        if (dir === -1) {
            ctx.translate(cx, 0);
            ctx.scale(-1, 1);
            ctx.translate(-cx, 0);
        }

        // Flicker if invincible
        if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // Draw Character (Procedural Vector Art)
        ctx.fillStyle = '#111'; // Base suit
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;

        // 1. Legs
        ctx.fillStyle = '#0a0a0a'; 
        let legOffset = 0;
        
        if (this.animState === ANIM.WALK) legOffset = Math.sin(this.frame * 0.2) * 10;
        if (this.animState === ANIM.KICK) legOffset = -20;
        
        // Back Leg
        ctx.beginPath();
        ctx.moveTo(cx - 10, cy - 50);
        ctx.lineTo(cx - 25 - legOffset, cy); // Ankle
        ctx.lineTo(cx - 5 - legOffset, cy); // Foot
        ctx.lineTo(cx, cy - 50);
        ctx.fill();
        ctx.stroke();

        // Front Leg
        ctx.beginPath();
        ctx.moveTo(cx + 10, cy - 50);
        ctx.lineTo(cx + 25 + legOffset, cy);
        ctx.lineTo(cx + 5 + legOffset, cy);
        ctx.lineTo(cx, cy - 50);
        ctx.fill();
        ctx.stroke();

        // 2. Torso
        ctx.fillStyle = this.color;
        // Main body
        ctx.fillRect(cx - 20, cy - 90, 40, 45);
        // Armor detail
        ctx.fillStyle = '#222';
        ctx.fillRect(cx - 15, cy - 85, 30, 10); // Vest top
        ctx.fillStyle = this.color;
        ctx.fillRect(cx - 15, cy - 70, 30, 20); // Vest bottom

        // Belt
        ctx.fillStyle = '#444';
        ctx.fillRect(cx - 20, cy - 50, 40, 8);
        // Buckle
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(cx - 5, cy - 50, 10, 8);

        // 3. Head
        // Hood/Mask
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(cx, cy - 100, 18, 0, Math.PI * 2); // Head base
        ctx.fill();
        ctx.stroke();
        
        // Mask covering mouth
        ctx.fillStyle = '#222';
        ctx.fillRect(cx - 12, cy - 95, 24, 12);
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(cx - 8, cy - 105, 5, 4);
        ctx.fillRect(cx + 3, cy - 105, 5, 4);
        
        // 4. Arms
        let armX = cx + 20;
        let armY = cy - 80;
        let armExt = 0;

        if (this.animState === ANIM.PUNCH) {
            armExt = 35;
            armY -= 5;
        } else if (this.animState === ANIM.KICK) {
            armX = cx - 10; // Balance arms
            armY = cy - 70;
        } else if (this.animState === ANIM.SPECIAL) {
            armExt = 25;
            armY -= 10;
            // Draw energy charge
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.6 + Math.sin(this.frame * 0.5) * 0.4;
            ctx.beginPath();
            ctx.arc(cx + 50, cy - 85, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        } else if (this.animState === ANIM.BLOCK || this.animState === ANIM.CROUCH) {
            armX = cx + 15;
            armY = cy - 70;
        } else {
            // Idle/Breathing
            armY += Math.sin(this.frame * 0.05) * 2;
        }

        // Draw Arm
        ctx.fillStyle = '#d4a574'; // Skin tone
        ctx.fillRect(armX, armY, 20 + armExt, 10); // Upper arm
        // Glove
        ctx.fillStyle = '#111';
        ctx.fillRect(armX + 15 + armExt, armY - 2, 15, 14);

        // Back Arm (Occluded mostly)
        ctx.fillStyle = '#d4a574';
        ctx.fillRect(cx - 30, cy - 80, 15, 10);
        ctx.fillStyle = '#111';
        ctx.fillRect(cx - 35, cy - 82, 10, 14);

        // Draw Special Move Projectile (if any)
        if (this.animState === ANIM.SPECIAL && this.frame > 10 && this.frame < 20) {
            // Iceball / Fireball visual
             ctx.fillStyle = this.isP1 ? '#ffaa00' : '#00ffff';
             ctx.shadowBlur = 20;
             ctx.shadowColor = ctx.fillStyle;
             ctx.beginPath();
             ctx.arc(cx + 60 + (this.frame-10)*10, cy - 85, 12, 0, Math.PI*2);
             ctx.fill();
             ctx.shadowBlur = 0;
        }

        ctx.restore();
        
        // Debug Hitbox
        /*
        if (this.hitbox) {
            ctx.strokeStyle = 'red';
            ctx.strokeRect(this.hitbox.x, this.hitbox.y, this.hitbox.w, this.hitbox.h);
        }
        */
    }
}

// --- INSTANCES ---
const p1 = new Fighter(200, '#ffae00', true); // Scorpion Yellow
const p2 = new Fighter(800, '#00ccff', false); // Sub-Zero Blue

// --- FUNCTIONS ---

function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color, 8, 30 + Math.random()*20));
    }
}

function checkCollisions() {
    if (!p1.hitbox && !p2.hitbox) return;

    // P1 hitting P2
    if (p1.hitbox && rectIntersect(p1.hitbox, {x: p2.pos.x-30, y: p2.pos.y-110, w: 60, h: 110})) {
        // Special hit logic for visual flair
        if(p1.hitbox.isSpecial) addShake(10);
        p2.takeDamage(p1.hitbox);
        updateCombo(p1);
        p1.hitbox = null; // Consume hitbox
        ui.flash2.style.width = (p1.hitbox.damage * 2) + '%';
        setTimeout(() => ui.flash2.style.width = '0%', 100);
    }

    // P2 hitting P1
    if (p2.hitbox && rectIntersect(p2.hitbox, {x: p1.pos.x-30, y: p1.pos.y-110, w: 60, h: 110})) {
        if(p2.hitbox.isSpecial) addShake(10);
        p1.takeDamage(p2.hitbox);
        updateCombo(p2);
        p2.hitbox = null;
        ui.flash1.style.width = (p2.hitbox.damage * 2) + '%';
        setTimeout(() => ui.flash1.style.width = '0%', 100);
    }
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function updateCombo(attacker) {
    const now = gameTime;
    if (now - attacker.lastHitTime < 1500) { // 1.5s window
        attacker.comboCount++;
    } else {
        attacker.comboCount = 1;
    }
    attacker.lastHitTime = now;

    if (attacker.comboCount > 1) {
        ui.comboNum.textContent = attacker.comboCount;
        ui.comboContainer.style.display = 'block';
        ui.comboContainer.style.left = (attacker.pos.x) + 'px';
        
        // Reset combo UI timer
        clearTimeout(window.comboTimer);
        window.comboTimer = setTimeout(() => {
            ui.comboContainer.style.display = 'none';
        }, 1500);
    }
}

function updateHealthUI() {
    const p1Pct = (p1.health / p1.maxHealth) * 100;
    const p2Pct = (p2.health / p2.maxHealth) * 100;
    
    ui.health1.style.width = p1Pct + '%';
    ui.health2.style.width = p2Pct + '%';
}

function drawBackground() {
    // Sky
    let grad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    grad.addColorStop(0, '#1a0b2e');
    grad.addColorStop(1, '#4a1a40');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

    // Moon
    ctx.save();
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 40;
    ctx.fillStyle = '#ddd';
    ctx.beginPath();
    ctx.arc(800, 100, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Distant Mountains (Parallax Layer 1)
    ctx.fillStyle = '#0f0515';
    ctx.beginPath();
    ctx.moveTo(0, 500);
    for(let i=0; i<=CANVAS_W; i+=50) {
        ctx.lineTo(i, 400 + Math.sin(i * 0.01) * 50);
    }
    ctx.lineTo(CANVAS_W, 600);
    ctx.lineTo(0, 600);
    ctx.fill();

    // Closer Pillars/Rocks (Parallax Layer 2 - slight movement)
    const pX = bgOffset * 0.2;
    ctx.fillStyle = '#2a1a20';
    // Draw a few decorative pillars
    [0.2, 0.5, 0.8].forEach(frac => {
        let x = (CANVAS_W * frac - pX) % (CANVAS_W + 200);
        if (x < -100) x += CANVAS_W + 200;
        
        ctx.fillRect(x, 300, 60, 300); // Pillar
        // Pillar top
        ctx.beginPath();
        ctx.moveTo(x - 10, 300);
        ctx.lineTo(x + 30, 250);
        ctx.lineTo(x + 70, 300);
        ctx.fill();
    });

    // Ground
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, GROUND_Y, CANVAS_W, CANVAS_H - GROUND_Y);
    
    // Ground details (tiles)
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0; i<CANVAS_W; i+=100) {
        ctx.moveTo(i, GROUND_Y);
        ctx.lineTo(i - 100, CANVAS_H);
    }
    ctx.stroke();
    
    // Ambient Mist
    ctx.fillStyle = 'rgba(100, 50, 100, 0.1)';
    ctx.fillRect(0, GROUND_Y - 20, CANVAS_W, 80);
}

// --- GAME LOOP ---

function update() {
    // Delta time
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    gameTime = now;

    // FPS Counter
    frames++;
    if (frames % 30 === 0) ui.fps.textContent = `FPS: ${Math.round(1/dt)}`;

    if (gameState === STATE.PLAYING) {
        p1.update(p2);
        p2.update(p1);
        checkCollisions();
    }

    // Shake decay
    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;
    
    // Hit Stop logic
    if (hitStopFrames > 0) {
        hitStopFrames--;
        return; // Don't draw/update anything else this frame
    }

    // Draw
    ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
    
    // Apply shake
    ctx.save();
    if (shakeIntensity > 0) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }

    drawBackground();

    // Shadows
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.ellipse(p1.pos.x, GROUND_Y + 5, 30, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(p2.pos.x, GROUND_Y + 5, 30, 10, 0, 0, Math.PI*2);
    ctx.fill();

    p1.draw(ctx);
    p2.draw(ctx);

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    ctx.restore();

    requestAnimationFrame(update);
}

// --- GAME LOGIC CONTROL ---

function startGame() {
    ui.startMenu.classList.add('hidden');
    p1.reset();
    p2.reset();
    updateHealthUI();
    
    ui.centerText.innerHTML = "ROUND 1<br>FIGHT!";
    ui.centerText.classList.add('show-text');
    
    // Short delay before actual combat starts
    setTimeout(() => {
        ui.centerText.classList.remove('show-text');
        gameState = STATE.PLAYING;
        startTimer();
    }, 2000);
}

function startTimer() {
    clearInterval(timerInterval);
    timer = 99;
    ui.timer.innerText = timer;
    
    timerInterval = setInterval(() => {
        if (gameState !== STATE.PLAYING) return;
        
        timer--;
        ui.timer.innerText = timer;
        
        if (timer <= 10) {
            ui.timer.style.color = '#f00';
            ui.timer.style.transform = `translateX(-50%) skewX(-15deg) scale(${1 + (10-timer)*0.1})`;
        } else {
            ui.timer.style.color = '#fff';
            ui.timer.style.transform = 'translateX(-50%) skewX(-15deg) scale(1)';
        }

        if (timer <= 0) {
            // Time over logic
            clearInterval(timerInterval);
            if (p1.health > p2.health) endRound('PLAYER 1 WINS');
            else if (p2.health > p1.health) endRound('PLAYER 2 WINS');
            else endRound('DRAW GAME');
        }
    }, 1000);
}

function endRound(msg) {
    gameState = STATE.ENDED;
    clearInterval(timerInterval);
    ui.centerText.innerHTML = msg.replace(/ /g, '<br>');
    ui.centerText.classList.add('show-text');
    
    setTimeout(() => {
        ui.centerText.classList.remove('show-text');
        ui.gameOverMenu.classList.remove('hidden');
        ui.winnerText.innerText = msg;
    }, 3000);
}

function resetGame() {
    ui.gameOverMenu.classList.add('hidden');
    startGame();
}

// Start Loop
requestAnimationFrame(update);

</script>
</body>
</html>