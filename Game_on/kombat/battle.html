<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MORTAL ARENA: REALISM (FIXED)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Bangers&display=swap');
        
        :root {
            --p1-color: #ff4d00;
            --p2-color: #0088ff;
            --bg-top: #1a1a2e;
            --bg-bot: #000000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Bangers', cursive;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 1000px;
            height: 600px;
            background: #000; /* Fallback */
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border: 4px solid #444;
            overflow: hidden;
        }

        /* Canvases layered on top of each other */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }

        #gameCanvas { z-index: 2; } /* Main gameplay */
        #bloodCanvas { z-index: 1; pointer-events: none; } /* Persistent blood */
        
        /* Cinematic letterbox bars */
        .bar {
            position: absolute; left: 0; right: 0; height: 60px;
            background: #000; z-index: 100; pointer-events: none;
        }
        .top-bar { top: 0; }
        .bottom-bar { bottom: 0; }

        #ui {
            position: absolute;
            top: 0; left: 0; right: 0; padding: 70px 20px 0 20px;
            pointer-events: none; z-index: 10;
            display: flex; justify-content: space-between;
        }

        .hud-side {
            width: 40%; display: flex; flex-direction: column;
        }

        .name-tag {
            font-family: 'Press Start 2P', cursive; font-size: 14px;
            margin-bottom: 5px; text-shadow: 2px 2px 0 #000;
            display: flex; justify-content: space-between;
        }
        .p1-name { color: var(--p1-color); }
        .p2-name { color: var(--p2-color); flex-direction: row-reverse; }

        .health-box {
            height: 25px; background: #333;
            border: 2px solid #555;
            transform: skewX(-15deg);
            box-shadow: 0 4px 5px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%; width: 100%;
            transition: width 0.1s linear;
        }
        .p1-hp { background: linear-gradient(180deg, #ff3333, #880000); float: right; }
        .p2-hp { background: linear-gradient(180deg, #3388ff, #003388); float: left; }

        .timer-box {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 80px; height: 60px;
            background: #000; border: 2px solid #fff;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 32px; color: #fff;
            z-index: 5; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        #centerText {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 80px; font-family: 'Press Start 2P', cursive;
            text-shadow: 5px 5px 0 #500; color: #fff;
            pointer-events: none; z-index: 20;
            text-align: center; white-space: nowrap;
            opacity: 0; transition: opacity 0.2s;
        }
        .show { opacity: 1 !important; transform: translate(-50%, -50%) scale(1) !important; }

        .menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 50;
        }
        .hidden { display: none !important; }

        h1 { font-size: 40px; color: #a00; text-shadow: 0 0 20px #f00; margin-bottom: 20px; text-align: center; }

        button {
            background: #300; color: #fff; border: 2px solid #f00;
            padding: 15px 40px; font-family: 'Press Start 2P', cursive;
            font-size: 16px; cursor: pointer; margin: 10px;
            transition: 0.2s;
        }
        button:hover { background: #f00; color: #000; }

        .controls {
            margin-top: 30px; color: #aaa; font-family: monospace;
            text-align: center; line-height: 1.8;
            background: rgba(0,0,0,0.5); padding: 20px;
            border: 1px solid #444;
        }
        .key { color: #fff; border-bottom: 2px solid #fff; padding: 0 2px; }

        /* Visual Vignette */
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none; z-index: 15;
        }

    </style>
</head>
<body>

    <div id="gameContainer">
        <!-- Layers -->
        <canvas id="bloodCanvas" width="1000" height="600"></canvas>
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        <div id="vignette"></div>

        <!-- UI Overlay -->
        <div class="top-bar"></div>
        <div class="bottom-bar"></div>

        <div id="ui">
            <div class="hud-side p1-name">
                <div class="name-tag"><span>SCORPION</span></div>
                <div class="health-box"><div class="hp-bar p1-hp" id="h1"></div></div>
            </div>
            
            <div class="timer-box"><span id="timer">99</span></div>

            <div class="hud-side p2-name">
                <div class="name-tag"><span>SUB-ZERO</span></div>
                <div class="health-box"><div class="hp-bar p2-hp" id="h2"></div></div>
            </div>
        </div>

        <div id="centerText">FIGHT!</div>

        <!-- Menus -->
        <div id="startMenu" class="menu">
            <h1>MORTAL ARENA<br><span style="font-size:20px; color:#fff;">REALISM MODE</span></h1>
            <button onclick="startGame()">START FIGHT</button>
            <div class="controls">
                <span style="color:var(--p1-color)">P1:</span> <span class="key">A</span><span class="key">D</span> Move | <span class="key">W</span> Jump | <span class="key">S</span> Block/Crouch<br>
                <span class="key">J</span> Punch | <span class="key">K</span> Kick | <span class="key">L</span> Throw<br><br>
                <span style="color:var(--p2-color)">P2:</span> <span class="key">←</span><span class="key">→</span> Move | <span class="key">↑</span> Jump | <span class="key">↓</span> Block/Crouch<br>
                <span class="key">1</span> Punch | <span class="key">2</span> Kick | <span class="key">3</span> Throw<br><br>
                <em>Hold BACK to block attacks.</em>
            </div>
        </div>

        <div id="gameOverMenu" class="menu hidden">
            <h1 id="winner">FINISH HIM</h1>
            <button onclick="resetGame()">REMATCH</button>
        </div>
    </div>

<script>
/**
 * FIXED ENGINE
 * Robust loop, better visuals, crash prevention.
 */

const cvs = document.getElementById('gameCanvas');
const bloodCvs = document.getElementById('bloodCanvas');
const ctx = cvs.getContext('2d');
const bloodCtx = bloodCvs.getContext('2d');

// --- CONFIG ---
const W = 1000, H = 600;
const GROUND_Y = 500; // Floor position
const GRAVITY = 0.6;

// --- STATE ---
let gameState = 'MENU'; // MENU, PLAY, END
let frame = 0;
let timer = 99;
let timerInt;
let p1 = null;
let p2 = null;

// Camera
let camera = { x: 0, y: 0, scale: 1, targetScale: 1 };
let shake = 0;
let slowMo = 1.0; 

// --- BLOOD SYSTEM ---
const bloodParticles = [];

class BloodDrop {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 15;
        this.vy = (Math.random() - 1) * 15; 
        this.life = 100 + Math.random() * 50;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.onGround = false;
    }

    update() {
        if (this.onGround) return;
        this.x += this.vx * slowMo;
        this.y += this.vy * slowMo;
        this.vy += 0.5 * slowMo; 

        if (this.y > GROUND_Y) {
            this.y = GROUND_Y + (Math.random() * 5);
            this.splatter();
            this.onGround = true;
            this.life = 0;
        }
        this.life--;
    }

    draw(c) {
        if (this.onGround) return;
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0, Math.PI*2);
        c.fill();
    }

    splatter() {
        // Permanent stain
        bloodCtx.fillStyle = this.color;
        bloodCtx.globalAlpha = 0.8;
        bloodCtx.beginPath();
        bloodCtx.arc(this.x, this.y, this.size * (1 + Math.random()), 0, Math.PI*2);
        bloodCtx.fill();
        bloodCtx.globalAlpha = 1.0;
        
        // Drips
        for(let i=0; i<3; i++) {
            bloodCtx.fillStyle = this.color;
            bloodCtx.globalAlpha = 0.4;
            let sx = this.x + (Math.random()-0.5)*10;
            let sy = this.y - (Math.random()*10);
            bloodCtx.fillRect(sx, sy, Math.random()*3, 2);
        }
        bloodCtx.globalAlpha = 1.0;
    }
}

// --- FIGHTER CLASS ---
class Fighter {
    constructor(x, color, isP1) {
        this.startX = x;
        this.color = color;
        this.isP1 = isP1;
        this.reset();
    }

    reset() {
        this.x = this.startX;
        this.y = GROUND_Y;
        this.vx = 0;
        this.vy = 0;
        this.facing = this.isP1 ? 1 : -1;
        this.state = 'IDLE'; 
        this.animTimer = 0;
        this.health = 100;
        this.maxHealth = 100;
        this.stun = 0;
        this.invincible = 0;
        this.hitbox = null;
        this.isBlocking = false;
        this.dead = false;
    }

    update(enemy) {
        if (this.dead) return;

        const spd = slowMo;

        if (this.stun > 0) this.stun -= spd;
        if (this.invincible > 0) this.invincible -= spd;
        
        if (this.state === 'IDLE' || this.state === 'WALK' || this.state === 'CROUCH' || this.state === 'BLOCK') {
            this.vx *= 0.85;
        }

        this.vy += GRAVITY * spd;
        this.x += this.vx * spd;
        this.y += this.vy * spd;

        if (this.y >= GROUND_Y) {
            this.y = GROUND_Y;
            this.vy = 0;
            if (this.state === 'JUMP') this.state = 'IDLE';
        }

        if (this.x < 20) this.x = 20;
        if (this.x > 980) this.x = 980;

        // Auto-face
        if (!this.hitbox && this.stun <= 0 && Math.abs(this.x - enemy.x) > 20) {
            this.facing = this.x < enemy.x ? 1 : -1;
        }

        if (this.stun <= 0 && gameState === 'PLAY') {
            this.handleInput(enemy);
        }
        
        if (this.hitbox && this.animTimer <= 0) {
            this.hitbox = null;
            this.state = 'IDLE';
        }
        
        if (this.animTimer > 0) this.animTimer -= spd;
        if (this.animTimer <= 0 && this.state === 'HIT') this.state = 'IDLE';
    }

    handleInput(enemy) {
        const L = this.isP1 ? 'a' : 'arrowleft';
        const R = this.isP1 ? 'd' : 'arrowright';
        const U = this.isP1 ? 'w' : 'arrowup';
        const D = this.isP1 ? 's' : 'arrowdown';
        const P = this.isP1 ? 'j' : '1';
        const K = this.isP1 ? 'k' : '2';
        const T = this.isP1 ? 'l' : '3';

        const movingBack = (this.facing === 1 && keys[L]) || (this.facing === -1 && keys[R]);
        this.isBlocking = movingBack && !this.hitbox && this.stun <= 0;

        if (this.state !== 'JUMP' && !this.hitbox) {
            if (keys[L]) this.vx = -5;
            if (keys[R]) this.vx = 5;
            
            if (keys[L] || keys[R]) {
                if (!this.isBlocking) this.state = 'WALK';
            } else if (!this.isBlocking) {
                this.state = 'IDLE';
            }

            if (keys[D]) {
                this.state = 'CROUCH';
                this.vx = 0;
            } else if (this.state === 'CROUCH') {
                this.state = 'IDLE';
            }

            if (keys[U] && justPressed[U]) {
                this.vy = -14;
                this.state = 'JUMP';
            }

            if (justPressed[T]) this.attemptThrow(enemy);
            if (justPressed[P] && !this.isBlocking) this.attack('PUNCH', 15, 10, 8, 40, 0, 35, 30);
            if (justPressed[K] && !this.isBlocking) this.attack('KICK', 20, 12, 12, 50, 10, 40, 40);
        } else {
            if (keys[L]) this.vx = -3;
            if (keys[R]) this.vx = 3;
        }
    }

    attack(type, duration, hitFrame, dmg, w, yOff, hbW, hbH) {
        if (this.hitbox) return;
        this.state = type;
        this.hitbox = { w: hbW, h: hbH, xOff: 40, yOff: yOff, dmg: dmg, type: type };
        this.animTimer = duration;
        this.vx = 0; 

        setTimeout(() => {
            if (this.state === type) {
                const dir = this.facing;
                this.hitbox.x = this.x + (dir * this.hitbox.xOff) - (this.hitbox.w/2);
                this.hitbox.y = this.y - 120 + this.hitbox.yOff;
            }
        }, (hitFrame / 60) * 1000);
    }

    attemptThrow(enemy) {
        const dist = Math.abs(this.x - enemy.x);
        if (dist < 70 && enemy.y === GROUND_Y && enemy.state !== 'HIT' && !enemy.dead) {
            this.state = 'THROW';
            this.animTimer = 40;
            this.vx = 0;
            
            setTimeout(() => {
                if (gameState === 'PLAY') {
                    if (Math.abs(this.x - enemy.x) < 80) {
                        triggerShake(10);
                        triggerSlowMo(0.2, 20); 
                        enemy.takeDamage(12, this.facing * 15, -10, false); // Unblockable
                        createBlood(enemy.x, enemy.y - 80, 20); 
                    }
                }
            }, 300);
        }
    }

    takeDamage(dmg, knockX, knockY, isBlocked) {
        if (isBlocked) {
            dmg = dmg * 0.1; 
            triggerSlowMo(0.8, 5);
            createSparks(this.x, this.y - 80);
        } else {
            this.stun = 20;
            this.state = 'HIT';
            this.animTimer = 20;
            this.invincible = 15;
            this.vy = -5;
            triggerShake(5 + (dmg/2));
            createBlood(this.x, this.y - 80, dmg);
        }

        this.health -= dmg;
        if (this.health < 0) this.health = 0;
        
        this.vx = knockX;
        this.vy = knockY;
        
        updateUI();
        
        if (this.health <= 0) {
            this.dead = true;
            for(let i=0; i<30; i++) setTimeout(() => createBlood(this.x, this.y - 10, 5), i*20);
            endGame(this.isP1 ? 'SUB-ZERO WINS' : 'SCORPION WINS');
        }
    }

    draw() {
        if (this.dead) {
            this.drawDead();
            return;
        }

        let yOff = 0;
        if (this.state === 'CROUCH') yOff = 40;

        if (this.invincible > 0 && Math.floor(frame/3)%2===0) ctx.globalAlpha = 0.5;

        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.facing === -1) ctx.scale(-1, 1);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath();
        ctx.ellipse(0, 5, 35, 10, 0, 0, Math.PI*2);
        ctx.fill();

        // Leg Animation
        const legMove = (this.state === 'WALK') ? Math.sin(frame * 0.3) * 15 : 0;
        
        // Back Leg
        this.drawLimb(-15 + legMove, -50 - yOff, 20, 50, true);
        
        // Torso
        const torsoGrad = ctx.createLinearGradient(-20, -90 - yOff, 20, -50 - yOff);
        torsoGrad.addColorStop(0, '#222');
        torsoGrad.addColorStop(0.5, this.color);
        torsoGrad.addColorStop(1, '#000');
        ctx.fillStyle = torsoGrad;
        ctx.fillRect(-20, -90 - yOff, 40, 50);
        
        // Abs
        ctx.fillStyle = '#111';
        ctx.fillRect(-15, -75 - yOff, 30, 20);

        // Belt
        ctx.fillStyle = '#554433';
        ctx.fillRect(-22, -45 - yOff, 44, 8);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-5, -45 - yOff, 10, 8);

        // Front Leg
        this.drawLimb(15 - legMove, -50 - yOff, 20, 50, false);

        // Head
        ctx.fillStyle = '#dcb'; 
        ctx.beginPath();
        ctx.arc(0, -100 - yOff, 16, 0, Math.PI*2);
        ctx.fill();
        
        // Mask
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(-16, -100 - yOff);
        ctx.lineTo(16, -100 - yOff);
        ctx.lineTo(0, -75 - yOff);
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(-6, -105 - yOff, 4, 3);
        ctx.fillRect(2, -105 - yOff, 4, 3);

        // Arms
        let armX = 20, armY = -80 - yOff;
        
        if (this.state === 'PUNCH') { armX = 40; }
        else if (this.state === 'KICK') { armY = -90 - yOff; }
        else if (this.state === 'THROW') { armX = 30; armY = -90 - yOff; }
        else if (this.state === 'BLOCK') { armX = 10; armY = -90 - yOff; }
        else if (this.state === 'CROUCH') { armY = -70; }
        else { armY += Math.sin(frame * 0.1) * 2; } 

        this.drawLimb(-25, -80 - yOff, 10, 40, true);
        this.drawLimb(armX - 10, armY, 12, 40 + (this.state==='PUNCH'?30:0), false);

        ctx.restore();
        ctx.globalAlpha = 1;
    }

    drawLimb(x, y, w, h, isBack) {
        const grad = ctx.createLinearGradient(x - w/2, y, x + w/2, y);
        grad.addColorStop(0, '#111');
        grad.addColorStop(0.5, isBack ? '#1a1a1a' : '#444');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fillRect(x - w/2, y, w, h);
    }

    drawDead() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.PI / 2); 
        ctx.fillStyle = '#111';
        ctx.fillRect(-10, -60, 20, 120);
        ctx.fillStyle = this.color;
        ctx.fillRect(-12, -50, 24, 40);
        ctx.fillStyle = '#dcb';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

// --- FX SYSTEM ---
function createBlood(x, y, intensity) {
    const color = '#8a0000'; 
    const count = Math.min(50, intensity * 2);
    
    for(let i=0; i<count; i++) {
        const b = new BloodDrop(x, y, color);
        b.update(); 
        b.draw(bloodCtx); 
    }
    
    for(let i=0; i<count/2; i++) {
        bloodParticles.push(new BloodDrop(x, y, color));
    }
}

function createSparks(x, y) {
    for(let i=0; i<10; i++) {
        bloodParticles.push(new BloodDrop(x, y, '#ffffaa'));
    }
}

// --- INPUT & LOGIC ---
const keys = {};
const justPressed = {};

document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    justPressed[e.key.toLowerCase()] = true;
});
document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    justPressed[e.key.toLowerCase()] = false;
});

function startGame() {
    document.getElementById('startMenu').classList.add('hidden');
    document.getElementById('gameOverMenu').classList.add('hidden');
    document.getElementById('centerText').classList.remove('show');
    
    bloodCtx.clearRect(0,0,W,H);
    
    p1 = new Fighter(250, '#ff4d00', true);
    p2 = new Fighter(750, '#0088ff', false);
    updateUI();
    
    gameState = 'PLAY';
    timer = 99;
    
    const ct = document.getElementById('centerText');
    ct.innerHTML = "ROUND 1<br>FIGHT!";
    ct.classList.add('show');
    setTimeout(() => ct.classList.remove('show'), 2000);

    clearInterval(timerInt);
    timerInt = setInterval(() => {
        if(gameState === 'PLAY' && slowMo > 0.8) {
            timer--;
            document.getElementById('timer').innerText = timer;
            if(timer <= 0) endGame('DRAW');
        }
    }, 1000);
}

function resetGame() {
    startGame();
}

function endGame(msg) {
    gameState = 'END';
    clearInterval(timerInt);
    triggerSlowMo(0.2, 200); 
    
    setTimeout(() => {
        document.getElementById('winner').innerText = msg;
        document.getElementById('gameOverMenu').classList.remove('hidden');
        document.getElementById('centerText').innerHTML = "FATALITY";
        document.getElementById('centerText').classList.add('show');
    }, 2000);
}

function updateUI() {
    if (p1 && p2) {
        document.getElementById('h1').style.width = (p1.health/p1.maxHealth)*100 + '%';
        document.getElementById('h2').style.width = (p2.health/p2.maxHealth)*100 + '%';
    }
}

function checkHitboxes() {
    if (!p1 || !p2) return;
    
    if (p1.hitbox && rectHit(p1.hitbox, p2)) {
        const blocked = p2.isBlocking;
        p2.takeDamage(p1.hitbox.dmg, p1.facing * 8, -5, blocked);
        p1.hitbox = null;
    }
    if (p2.hitbox && rectHit(p2.hitbox, p1)) {
        const blocked = p1.isBlocking;
        p1.takeDamage(p2.hitbox.dmg, p2.facing * 8, -5, blocked);
        p2.hitbox = null;
    }
}

function rectHit(hb, char) {
    return hb.x < char.x + 30 &&
           hb.x + hb.w > char.x - 30 &&
           hb.y < char.y &&
           hb.y + hb.h > char.y - 120;
}

function triggerShake(amount) { shake = amount; }
function triggerSlowMo(factor, duration) {
    slowMo = factor;
    setTimeout(() => { slowMo = 1.0; }, duration * 1000 / (60 * factor));
}

// --- MAIN LOOP ---
function loop() {
    requestAnimationFrame(loop);
    
    frame++;
    
    if (shake > 0) shake *= 0.9;
    if (shake < 0.5) shake = 0;

    // Logic Update (Crash Protected)
    if (p1 && p2) {
        if (gameState === 'PLAY' || gameState === 'END') {
            p1.update(p2);
            p2.update(p1);
            checkHitboxes();
            
            // Camera update
            const dist = Math.abs(p1.x - p2.x);
            const idealScale = Math.max(0.7, 1000 / (dist + 400));
            if (slowMo >= 0.9) camera.scale += (idealScale - camera.scale) * 0.1;
        }
    }

    // Particles
    for(let i=bloodParticles.length-1; i>=0; i--) {
        const b = bloodParticles[i];
        b.update();
        b.draw(ctx);
        if(b.life <= 0) bloodParticles.splice(i, 1);
    }

    // --- RENDERING ---
    ctx.clearRect(0, 0, W, H);

    // 1. Background Gradient
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#1a1a2e');
    bgGrad.addColorStop(1, '#000000');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0,0,W,H);

    // 2. Moon
    ctx.save();
    ctx.shadowBlur = 50;
    ctx.shadowColor = '#500';
    ctx.fillStyle = '#300';
    ctx.beginPath();
    ctx.arc(800, 150, 60, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Camera Transform
    ctx.save();
    
    ctx.translate(W/2, H/2);
    ctx.scale(camera.scale, camera.scale);
    
    if (shake > 0) {
        ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
    }
    
    // Center on players
    let midX = 500; // Default center
    if (p1 && p2) {
        midX = (p1.x + p2.x) / 2;
    }
    ctx.translate(-midX, -H/2); 

    // 3. Floor (Visible Grid)
    ctx.fillStyle = '#0a0a0a'; // Floor color
    ctx.fillRect(-500, GROUND_Y, 2000, 200);
    
    // Floor Grid Lines (for depth perception)
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Perspective lines
    for(let i=-500; i<1500; i+=10) {
        ctx.moveTo(i, GROUND_Y);
        ctx.lineTo(i - 400, H + 100);
    }
    // Horizontal lines
    for(let i=0; i<200; i+=40) {
        ctx.moveTo(-500, GROUND_Y + i);
        ctx.lineTo(1500, GROUND_Y + i);
    }
    ctx.stroke();

    // 4. Persistent Blood Layer
    ctx.drawImage(bloodCvs, 0, 0);

    // 5. Fighters
    if (p1) p1.draw();
    if (p2) p2.draw();

    ctx.restore();
}

// Start
loop();

</script>
</body>
</html>