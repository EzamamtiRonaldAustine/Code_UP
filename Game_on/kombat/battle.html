<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MORTAL ARENA: ULTIMATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Bangers&display=swap');
        
        :root {
            --p1-color: #ff5500;
            --p2-color: #00ccff;
            --super-color: #ffd700;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            background: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Bangers', cursive;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 1000px;
            height: 600px;
            background: #000;
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
            border: 4px solid #333;
            overflow: hidden;
        }

        canvas { position: absolute; top: 0; left: 0; display: block; }
        #gameCanvas { z-index: 2; }
        #bloodCanvas { z-index: 1; pointer-events: none; }

        .bar {
            position: absolute; left: 0; right: 0; height: 50px;
            background: #000; z-index: 100; pointer-events: none;
            box-shadow: 0 0 20px #000;
        }
        .top-bar { top: 0; border-bottom: 2px solid #333; }
        .bottom-bar { bottom: 0; border-top: 2px solid #333; }

        #ui {
            position: absolute; top: 0; left: 0; right: 0; padding: 60px 20px 0 20px;
            pointer-events: none; z-index: 10;
        }

        .hud-side {
            width: 40%; display: flex; flex-direction: column;
        }

        .name-tag {
            font-family: 'Press Start 2P', cursive; font-size: 14px;
            margin-bottom: 2px; text-shadow: 2px 2px 0 #000;
            display: flex; justify-content: space-between;
            align-items: center;
        }
        .p1-name { color: var(--p1-color); text-align: left; }
        .p2-name { color: var(--p2-color); text-align: right; flex-direction: row-reverse; }

        .bars-wrapper {
            transform: skewX(-15deg);
            border: 2px solid #555;
            background: #111;
            padding: 2px;
            margin-bottom: 5px;
        }

        .hp-bar {
            height: 20px; width: 100%;
            transition: width 0.1s linear;
        }
        .p1-hp { background: linear-gradient(90deg, #500, #ff0000); float: right; }
        .p2-hp { background: linear-gradient(90deg, #0055aa, #00ccff); float: left; }

        .super-bar {
            height: 8px; width: 0%; background: #ffd700;
            box-shadow: 0 0 5px #ffd700;
            transition: width 0.1s;
        }

        .timer-box {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 80px; height: 60px;
            background: #000; border: 2px solid #fff;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 32px; color: #fff;
            z-index: 5; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        #centerText {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 80px; font-family: 'Press Start 2P', cursive;
            text-shadow: 5px 5px 0 #a00, 0 0 20px #fff; color: #fff;
            pointer-events: none; z-index: 20;
            text-align: center; white-space: nowrap;
            opacity: 0; transition: opacity 0.2s;
        }
        .show { opacity: 1 !important; transform: translate(-50%, -50%) scale(1) !important; }

        #comboUI {
            position: absolute; top: 150px; left: 100px;
            font-family: 'Press Start 2P', cursive;
            color: #ffd700; text-shadow: 2px 2px 0 #000;
            font-size: 40px; pointer-events: none; display: none;
            z-index: 8;
        }

        .menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 50;
        }
        .hidden { display: none !important; }

        h1 { font-size: 40px; color: #a00; text-shadow: 0 0 20px #f00; margin-bottom: 20px; text-align: center; }

        button {
            background: #300; color: #fff; border: 2px solid #f00;
            padding: 15px 40px; font-family: 'Press Start 2P', cursive;
            font-size: 16px; cursor: pointer; margin: 10px;
            transition: 0.2s;
        }
        button:hover { background: #f00; color: #000; transform: scale(1.05); }

        .controls {
            margin-top: 20px; color: #aaa; font-family: monospace;
            text-align: center; line-height: 1.6;
            background: rgba(255,255,255,0.05); padding: 20px;
            border: 1px solid #444; font-size: 13px;
        }
        .key { color: #fff; border-bottom: 2px solid #fff; padding: 0 3px; font-weight: bold;}
        
        .toggle-box {
            margin: 15px 0; display: flex; align-items: center; gap: 10px; font-size: 24px; font-family: 'Bangers';
        }
        .switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border: 1px solid #fff;
        }
        .slider:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s;
        }
        input:checked + .slider { background-color: var(--p2-color); }
        input:checked + .slider:before { transform: translateX(24px); }

        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.9) 100%);
            pointer-events: none; z-index: 15;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="bloodCanvas" width="1000" height="600"></canvas>
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        <div id="vignette"></div>

        <div class="top-bar"></div>
        <div class="bottom-bar"></div>

        <div id="ui">
            <div class="hud-side p1-name">
                <div class="name-tag"><span>SCORPION</span></div>
                <div class="bars-wrapper">
                    <div class="hp-bar p1-hp" id="h1"></div>
                    <div class="super-bar" id="s1"></div>
                </div>
            </div>
            
            <div class="timer-box"><span id="timer">99</span></div>

            <div class="hud-side p2-name">
                <div class="name-tag"><span>SUB-ZERO</span></div>
                <div class="bars-wrapper">
                    <div class="hp-bar p2-hp" id="h2"></div>
                    <div class="super-bar" id="s2"></div>
                </div>
            </div>
        </div>

        <div id="comboUI">2 HITS</div>
        <div id="centerText">FIGHT!</div>

        <div id="startMenu" class="menu">
            <h1>MORTAL ARENA<br><span style="font-size:18px; color:#fff;">ULTIMATE EDITION</span></h1>
            
            <div class="toggle-box">
                VS CPU
                <label class="switch">
                    <input type="checkbox" id="cpuToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <button onclick="startGame()">START FIGHT</button>
            <div class="controls">
                <span style="color:var(--p1-color)">P1:</span> <span class="key">A</span><span class="key">D</span> Move | <span class="key">W</span> Jump | <span class="key">S</span> Block<br>
                <span class="key">J</span> Punch | <span class="key">K</span> Kick | <span class="key">L</span> Throw | <span class="key">;</span> Special<br><br>
                <span style="color:var(--p2-color)">P2:</span> <span class="key">←</span><span class="key">→</span> Move | <span class="key">↑</span> Jump | <span class="key">↓</span> Block<br>
                <span class="key">1</span> Punch | <span class="key">2</span> Kick | <span class="key">3</span> Throw | <span class="key">4</span> Special<br><br>
                <em>Special costs 100% Super Meter.</em>
            </div>
        </div>

        <div id="gameOverMenu" class="menu hidden">
            <h1 id="winner">FINISH HIM</h1>
            <button onclick="resetGame()">REMATCH</button>
        </div>
    </div>

<script>
/**
 * ULTIMATE ENGINE
 * Features: Vector Graphics, Super Meter, Projectiles, AI, Combo System.
 */

const cvs = document.getElementById('gameCanvas');
const bloodCvs = document.getElementById('bloodCanvas');
const ctx = cvs.getContext('2d');
const bloodCtx = bloodCvs.getContext('2d');

// --- CONFIG ---
const W = 1000, H = 600;
const GROUND_Y = 500;
const GRAVITY = 0.6;

// --- STATE ---
let gameState = 'MENU';
let frame = 0;
let timer = 99;
let timerInt;
let p1 = null;
let p2 = null;
let projectiles = [];

let camera = { scale: 1, shake: 0 };
let slowMo = 1.0;
let combo = { count: 0, attacker: null, timer: 0 };

// --- INPUT ---
const keys = {};
const justPressed = {};
document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    justPressed[e.key.toLowerCase()] = true;
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) e.preventDefault();
});
document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
    justPressed[e.key.toLowerCase()] = false;
});

// --- CLASSES ---

class Projectile {
    constructor(x, y, dir, color, type) {
        this.x = x;
        this.y = y;
        this.vx = dir * 12;
        this.radius = 15;
        this.color = color;
        this.type = type; // 'fire' or 'ice'
        this.life = 100;
        this.active = true;
    }
    update() {
        if (slowMo < 1.0) this.x += this.vx * slowMo;
        else this.x += this.vx;
        
        this.life--;
        if (this.life <= 0 || this.x < -100 || this.x > W + 100) this.active = false;
        
        // Trail particles
        if (this.active && frame % 2 === 0) {
            createParticles(this.x, this.y, this.color, 1, 5, 'trail');
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        
        // Core
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fill();
        
        // Inner
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class Fighter {
    constructor(x, color, isP1) {
        this.startX = x;
        this.color = color; // Primary uniform color
        this.isP1 = isP1;
        this.reset();
    }

    reset() {
        this.x = this.startX;
        this.y = GROUND_Y;
        this.vx = 0;
        this.vy = 0;
        this.facing = this.isP1 ? 1 : -1;
        this.state = 'IDLE';
        this.animTimer = 0;
        this.health = 100;
        this.maxHealth = 100;
        this.super = 0;
        this.stun = 0;
        this.invincible = 0;
        this.hitbox = null;
        this.isBlocking = false;
        this.dead = false;
    }

    update(enemy) {
        if (this.dead) return;

        const spd = slowMo;

        // Timers
        if (this.stun > 0) this.stun -= spd;
        if (this.invincible > 0) this.invincible -= spd;
        if (this.animTimer > 0) this.animTimer -= spd;
        
        // Friction
        if (['IDLE', 'WALK', 'CROUCH', 'BLOCK'].includes(this.state)) {
            this.vx *= 0.85;
        }

        // Physics
        this.vy += GRAVITY * spd;
        this.x += this.vx * spd;
        this.y += this.vy * spd;

        // Ground
        if (this.y >= GROUND_Y) {
            this.y = GROUND_Y;
            this.vy = 0;
            if (this.state === 'JUMP') this.state = 'IDLE';
        }

        // Walls
        if (this.x < 30) this.x = 30;
        if (this.x > 970) this.x = 970;

        // Auto Face
        if (!this.hitbox && this.stun <= 0 && Math.abs(this.x - enemy.x) > 20) {
            this.facing = this.x < enemy.x ? 1 : -1;
        }

        // Input
        if (this.stun <= 0 && gameState === 'PLAY') {
            this.handleInput(enemy);
        }
        
        // Attack Cleanup
        if (this.hitbox && this.animTimer <= 0) {
            this.hitbox = null;
            this.state = 'IDLE';
        }
        
        // Hit Recovery
        if (this.animTimer <= 0 && this.state === 'HIT') this.state = 'IDLE';
    }

    handleInput(enemy) {
        const L = this.isP1 ? 'a' : 'arrowleft';
        const R = this.isP1 ? 'd' : 'arrowright';
        const U = this.isP1 ? 'w' : 'arrowup';
        const D = this.isP1 ? 's' : 'arrowdown';
        const P = this.isP1 ? 'j' : '1';
        const K = this.isP1 ? 'k' : '2';
        const T = this.isP1 ? 'l' : '3';
        const SP = this.isP1 ? ';' : '4'; // Special Key

        // AI Override
        if (!this.isP1 && document.getElementById('cpuToggle').checked) {
            this.runAI(enemy, L, R, U, D, P, K, T, SP);
            return;
        }

        const movingBack = (this.facing === 1 && keys[L]) || (this.facing === -1 && keys[R]);
        this.isBlocking = movingBack && !this.hitbox && this.stun <= 0;

        if (this.state !== 'JUMP' && !this.hitbox) {
            if (keys[L]) this.vx = -5;
            if (keys[R]) this.vx = 5;
            
            if (keys[L] || keys[R]) {
                if (!this.isBlocking) {
                    this.state = 'WALK';
                    // Dust particles
                    if(frame % 10 === 0) createParticles(this.x, this.y, '#555', 1, 10, 'dust');
                }
            } else if (!this.isBlocking) {
                this.state = 'IDLE';
            }

            if (keys[D]) {
                this.state = 'CROUCH';
                this.vx = 0;
            } else if (this.state === 'CROUCH') {
                this.state = 'IDLE';
            }

            if (keys[U] && justPressed[U]) {
                this.vy = -15;
                this.state = 'JUMP';
                createParticles(this.x, this.y, '#555', 5, 15, 'dust');
            }

            if (justPressed[T]) this.attemptThrow(enemy);
            if (justPressed[P] && !this.isBlocking) this.attack('PUNCH', 15, 10, 8, 40, 0, 40, 30);
            if (justPressed[K] && !this.isBlocking) this.attack('KICK', 20, 12, 12, 55, 10, 50, 40);
            if (justPressed[SP] && this.super >= 100 && !this.isBlocking) this.doSpecial();
        } else {
            if (keys[L]) this.vx = -4;
            if (keys[R]) this.vx = 4;
        }
    }

    runAI(enemy, L, R, U, D, P, K, T, SP) {
        const dist = Math.abs(this.x - enemy.x);
        
        // Reset fake keys
        keys[L] = false; keys[R] = false; keys[U] = false; 
        justPressed[U] = false; justPressed[P] = false; justPressed[K] = false;

        if (this.stun > 0) return;

        if (dist > 150) {
            // Approach
            keys[this.x < enemy.x ? R : L] = true;
            // Random Jump
            if (Math.random() < 0.01) justPressed[U] = true;
        } else if (dist < 80) {
            // Close combat
            if (enemy.isAttacking && Math.random() < 0.3) {
                keys[D] = true; // Block
            } else {
                keys[D] = false;
                // Attack
                if (Math.random() < 0.05) justPressed[K] = true;
                if (Math.random() < 0.02) justPressed[P] = true;
                if (Math.random() < 0.01) justPressed[T] = true;
                if (this.super >= 100 && Math.random() < 0.005) justPressed[SP] = true;
            }
        }
        
        // Re-inject input logic (recursive call to human logic is easier but we need to be careful of infinite loops.
        // We'll just set the global 'keys' object and let handleInput read them.
        // Note: Since this is called *inside* handleInput, we must exit to avoid double processing.
        return; 
    }

    attack(type, duration, hitFrame, dmg, w, yOff, hbW, hbH) {
        if (this.hitbox) return;
        this.state = type;
        this.hitbox = { w: hbW, h: hbH, xOff: 40, yOff: yOff, dmg: dmg, type: type };
        this.animTimer = duration;
        this.vx = 0; 

        setTimeout(() => {
            if (this.state === type) {
                const dir = this.facing;
                this.hitbox.x = this.x + (dir * this.hitbox.xOff) - (this.hitbox.w/2);
                this.hitbox.y = this.y - 130 + this.hitbox.yOff;
            }
        }, (hitFrame / 60) * 1000);
    }

    doSpecial() {
        this.super = 0;
        this.state = 'SPECIAL';
        this.animTimer = 30;
        this.vx = 0;
        
        // Charge effect
        createParticles(this.x, this.y - 80, this.color, 20, 10, 'trail');

        setTimeout(() => {
            if (gameState === 'PLAY') {
                projectiles.push(new Projectile(
                    this.x + (this.facing * 50),
                    this.y - 80,
                    this.facing,
                    this.color,
                    this.isP1 ? 'fire' : 'ice'
                ));
            }
        }, 300);
    }

    attemptThrow(enemy) {
        const dist = Math.abs(this.x - enemy.x);
        if (dist < 70 && enemy.y === GROUND_Y && enemy.state !== 'HIT' && !enemy.dead) {
            this.state = 'THROW';
            this.animTimer = 40;
            this.vx = 0;
            
            setTimeout(() => {
                if (gameState === 'PLAY' && Math.abs(this.x - enemy.x) < 80) {
                    camera.shake = 10;
                    triggerSlowMo(0.2, 15); 
                    enemy.takeDamage(15, this.facing * 12, -8, false); 
                    createBlood(enemy.x, enemy.y - 80, 20); 
                    addSuper(this, 20); // Gain meter on throw
                }
            }, 300);
        }
    }

    takeDamage(dmg, knockX, knockY, isBlocked) {
        if (isBlocked) {
            dmg = dmg * 0.05; // Low chip damage
            triggerSlowMo(0.8, 5);
            createSparks(this.x, this.y - 80);
            addSuper(this, 5); // Gain meter on block
        } else {
            this.stun = 20;
            this.state = 'HIT';
            this.animTimer = 20;
            this.invincible = 15;
            this.vy = -4;
            camera.shake = 5 + (dmg/2);
            createBlood(this.x, this.y - 80, dmg);
            addSuper(this, 15); // Gain meter on hit
        }

        this.health -= dmg;
        if (this.health < 0) this.health = 0;
        
        this.vx = knockX;
        this.vy = knockY;
        
        // Combo Logic
        if (!isBlocked) {
            if (combo.attacker === this) {
                combo.count = 0; // Self hit resets
            }
            // Note: combo tracker is handled in the collision logic usually, 
            // but here we just reset if victim is hit.
        }
        
        updateUI();
        
        if (this.health <= 0) {
            this.dead = true;
            this.die();
            endGame(this.isP1 ? 'SUB-ZERO WINS' : 'SCORPION WINS');
        }
    }

    die() {
        for(let i=0; i<30; i++) setTimeout(() => createBlood(this.x, this.y - 10, 5), i*20);
    }

    draw() {
        if (this.dead) {
            this.drawDead();
            return;
        }

        // Crouch Offset
        let yOff = 0;
        if (this.state === 'CROUCH') yOff = 40;

        // Flicker
        if (this.invincible > 0 && Math.floor(frame/4)%2===0) ctx.globalAlpha = 0.5;

        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.facing === -1) ctx.scale(-1, 1);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(0, 5, 40, 12, 0, 0, Math.PI*2);
        ctx.fill();

        // --- VECTOR CHARACTER ART ---
        
        // Animation Offsets
        const breath = Math.sin(frame * 0.05) * 2;
        const legAnim = (this.state === 'WALK') ? Math.sin(frame * 0.3) * 20 : 0;

        // BACK LEG
        this.drawLeg(-15 + legAnim, -50 - yOff, 22, 55, true);

        // TORSO
        ctx.fillStyle = '#111';
        ctx.beginPath();
        // Shoulders to Waist
        ctx.moveTo(-25, -90 - yOff + breath);
        ctx.lineTo(25, -90 - yOff + breath);
        ctx.lineTo(20, -40 - yOff);
        ctx.lineTo(-20, -40 - yOff);
        ctx.fill();
        // Muscle Definition
        ctx.fillStyle = '#222';
        ctx.fillRect(-10, -80 - yOff + breath, 20, 35);
        
        // ARMOR/Chest
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(-22, -85 - yOff + breath);
        ctx.lineTo(22, -85 - yOff + breath);
        ctx.lineTo(18, -55 - yOff);
        ctx.lineTo(-18, -55 - yOff);
        ctx.fill();
        // Armor Detail
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-5, -80 - yOff + breath, 10, 20);

        // BELT
        ctx.fillStyle = '#443322';
        ctx.fillRect(-24, -42 - yOff, 48, 10);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-6, -42 - yOff, 12, 10);

        // FRONT LEG
        this.drawLeg(15 - legAnim, -50 - yOff, 22, 55, false);

        // HEAD
        // Hood
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, -110 - yOff + breath, 18, 0, Math.PI*2);
        ctx.fill();
        // Mask
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(-18, -110 - yOff + breath);
        ctx.lineTo(18, -110 - yOff + breath);
        ctx.lineTo(12, -90 - yOff + breath);
        ctx.lineTo(-12, -90 - yOff + breath);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(-8, -115 - yOff + breath, 5, 4);
        ctx.fillRect(3, -115 - yOff + breath, 5, 4);

        // ARMS
        let armX = 25, armY = -85 - yOff + breath;
        
        if (this.state === 'PUNCH') { armX = 55; armY -= 5; }
        else if (this.state === 'KICK') { armY = -90 - yOff + breath; armX = 20; }
        else if (this.state === 'THROW') { armX = 35; armY = -90 - yOff + breath; }
        else if (this.state === 'BLOCK') { armX = 15; armY = -95 - yOff + breath; }
        else if (this.state === 'SPECIAL') { armX = 30; armY = -90 - yOff + breath; }
        else if (this.state === 'CROUCH') { armY = -75; }
        else { armY += 0; } 

        // Back Arm
        this.drawArm(-30, -80 - yOff + breath, 14, 45, true);
        // Front Arm
        this.drawArm(armX - 10, armY, 15, 50 + (this.state==='PUNCH'?40:0), false);

        ctx.restore();
        ctx.globalAlpha = 1;
    }

    drawLeg(x, y, w, h, isBack) {
        ctx.fillStyle = '#111';
        ctx.fillRect(x - w/2, y, w, h);
        // Boot
        ctx.fillStyle = '#222';
        ctx.fillRect(x - w/2, y + h - 15, w, 18);
    }

    drawArm(x, y, w, h, isBack) {
        ctx.fillStyle = '#111';
        ctx.fillRect(x, y, w, h);
        // Glove/Hand
        ctx.fillStyle = isBack ? '#444' : (this.isP1 ? '#ffcc00' : '#00ffff');
        ctx.fillRect(x - 2, y + h - 10, w + 4, 14);
    }

    drawDead() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.PI / 2); 
        ctx.fillStyle = '#111';
        ctx.fillRect(-10, -60, 20, 120);
        ctx.fillStyle = this.color;
        ctx.fillRect(-12, -50, 24, 40);
        ctx.fillStyle = '#dcb';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

// --- FX & LOGIC ---

function addSuper(fighter, amount) {
    fighter.super += amount;
    if (fighter.super > 100) fighter.super = 100;
    updateUI();
}

function createBlood(x, y, intensity) {
    const color = '#8a0000'; 
    const count = Math.min(50, intensity * 2);
    for(let i=0; i<count; i++) {
        // Immediate stain
        const b = { x: x + (Math.random()-0.5)*20, y: y + (Math.random()-0.5)*20 };
        bloodCtx.fillStyle = color;
        bloodCtx.globalAlpha = 0.6 + Math.random()*0.4;
        bloodCtx.beginPath();
        bloodCtx.arc(b.x, b.y, Math.random()*5, 0, Math.PI*2);
        bloodCtx.fill();
    }
    // Flying particles
    for(let i=0; i<count/2; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10 - 5,
            life: 30 + Math.random()*20, type: 'blood'
        });
    }
    bloodCtx.globalAlpha = 1.0;
}

function createSparks(x, y) {
    for(let i=0; i<10; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
            life: 15, type: 'spark'
        });
    }
}

function createParticles(x, y, color, count, life, type) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5 - 2,
            life: life, type: type, color: color
        });
    }
}

let particles = [];
function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx * slowMo;
        p.y += p.vy * slowMo;
        if (p.type === 'blood') p.vy += 0.5;
        p.life--;
        
        // Draw
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.type === 'blood' ? '#8a0000' : (p.color || '#fff');
        ctx.beginPath();
        if (p.type === 'trail') ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
        else ctx.fillRect(p.x, p.y, 3, 3);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        if (p.life <= 0) particles.splice(i, 1);
    }
}

function startGame() {
    document.getElementById('startMenu').classList.add('hidden');
    document.getElementById('gameOverMenu').classList.add('hidden');
    document.getElementById('centerText').classList.remove('show');
    bloodCtx.clearRect(0,0,W,H);
    
    p1 = new Fighter(250, '#ff5500', true);
    p2 = new Fighter(750, '#00ccff', false);
    projectiles = [];
    particles = [];
    combo = { count: 0, attacker: null, timer: 0 };
    updateUI();
    
    gameState = 'PLAY';
    timer = 99;
    
    const ct = document.getElementById('centerText');
    ct.innerHTML = "ROUND 1<br>FIGHT!";
    ct.classList.add('show');
    setTimeout(() => ct.classList.remove('show'), 2000);

    clearInterval(timerInt);
    timerInt = setInterval(() => {
        if(gameState === 'PLAY' && slowMo > 0.8) {
            timer--;
            document.getElementById('timer').innerText = timer;
            if(timer <= 0) endGame('DRAW');
        }
    }, 1000);
}

function resetGame() {
    startGame();
}

function endGame(msg) {
    gameState = 'END';
    clearInterval(timerInt);
    triggerSlowMo(0.2, 200); 
    
    setTimeout(() => {
        document.getElementById('winner').innerText = msg;
        document.getElementById('gameOverMenu').classList.remove('hidden');
        document.getElementById('centerText').innerHTML = "FATALITY";
        document.getElementById('centerText').classList.add('show');
    }, 2000);
}

function updateUI() {
    if (p1 && p2) {
        document.getElementById('h1').style.width = (p1.health/p1.maxHealth)*100 + '%';
        document.getElementById('h2').style.width = (p2.health/p2.maxHealth)*100 + '%';
        document.getElementById('s1').style.width = p1.super + '%';
        document.getElementById('s2').style.width = p2.super + '%';
    }
}

function checkHitboxes() {
    if (!p1 || !p2) return;
    
    // Physical Hits
    const check = (attacker, defender) => {
        if (attacker.hitbox && rectHit(attacker.hitbox, defender)) {
            const blocked = defender.isBlocking;
            defender.takeDamage(attacker.hitbox.dmg, attacker.facing * 8, -5, blocked);
            attacker.hitbox = null;
            
            if (!blocked) {
                // Combo tracking
                if (combo.attacker === attacker && combo.timer > 0) {
                    combo.count++;
                } else {
                    combo.count = 1;
                }
                combo.attacker = attacker;
                combo.timer = 60; // 1 second window
                
                // UI Update
                const ui = document.getElementById('comboUI');
                ui.innerText = combo.count + " HIT COMBO";
                ui.style.display = 'block';
                ui.style.left = attacker.x + 'px';
                ui.style.color = attacker.isP1 ? '#ff5500' : '#00ccff';
            } else {
                combo.count = 0;
                document.getElementById('comboUI').style.display = 'none';
            }
        }
    };
    
    check(p1, p2);
    check(p2, p1);

    // Projectile Hits
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        // P1 Proj hits P2
        if (p.facing === 1 && rectHit({x:p.x-15, y:p.y-15, w:30, h:30}, p2)) {
            p.active = false;
            p2.takeDamage(15, 8, -10, p2.isBlocking);
        }
        // P2 Proj hits P1
        if (p.facing === -1 && rectHit({x:p.x-15, y:p.y-15, w:30, h:30}, p1)) {
            p.active = false;
            p1.takeDamage(15, -8, -10, p1.isBlocking);
        }
    }
}

function rectHit(hb, char) {
    return hb.x < char.x + 30 &&
           hb.x + hb.w > char.x - 30 &&
           hb.y < char.y &&
           hb.y + hb.h > char.y - 130;
}

function triggerSlowMo(factor, duration) {
    slowMo = factor;
    setTimeout(() => { slowMo = 1.0; }, duration * 1000 / (60 * factor));
}

// --- MAIN LOOP ---
function loop() {
    requestAnimationFrame(loop);
    frame++;
    
    if (camera.shake > 0) camera.shake *= 0.9;

    if (p1 && p2) {
        if (gameState === 'PLAY' || gameState === 'END') {
            p1.update(p2);
            p2.update(p1);
            checkHitboxes();
            
            // Update Projectiles
            for(let i=projectiles.length-1; i>=0; i--) {
                projectiles[i].update();
                if(!projectiles[i].active) projectiles.splice(i, 1);
            }

            // Camera Zoom
            const dist = Math.abs(p1.x - p2.x);
            const idealScale = Math.max(0.75, 1000 / (dist + 350));
            if (slowMo >= 0.9) camera.scale += (idealScale - camera.scale) * 0.1;
        }
    }
    
    // Combo Timer
    if (combo.timer > 0) {
        combo.timer--;
        if (combo.timer <= 0) document.getElementById('comboUI').style.display = 'none';
    }

    updateParticles();

    // RENDER
    ctx.clearRect(0, 0, W, H);

    // Background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#1a0b2e');
    bgGrad.addColorStop(1, '#000000');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0,0,W,H);
    
    // Moon
    ctx.save();
    ctx.shadowBlur = 40;
    ctx.shadowColor = '#500';
    ctx.fillStyle = '#300';
    ctx.beginPath();
    ctx.arc(800, 150, 70, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Camera Transform
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(camera.scale, camera.scale);
    if (camera.shake > 0) ctx.translate((Math.random()-0.5)*camera.shake, (Math.random()-0.5)*camera.shake);
    
    let midX = (p1 && p2) ? (p1.x + p2.x) / 2 : 500;
    ctx.translate(-midX, -H/2); 

    // Floor
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(-500, GROUND_Y, 2000, 200);
    
    // Grid
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=-500; i<1500; i+=100) {
        ctx.moveTo(i, GROUND_Y);
        ctx.lineTo(i - 300, H + 100);
    }
    ctx.stroke();

    // Objects
    ctx.drawImage(bloodCvs, 0, 0);
    
    // Draw Fighters & Projectiles
    if (p1) p1.draw();
    if (p2) p2.draw();
    
    projectiles.forEach(p => p.draw());

    ctx.restore();
}

// Init
loop();

</script>
</body>
</html>